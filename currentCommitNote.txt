feat(all): Add fine-grained isomorphic authorization

Show/enable or hide/disable React components, individual HTML elements 
and server-side methods according to rules recorded in the data base.

A rule has the format :

    {
      "_id" : "sDiRmPCmwtTwST3nb",
      "removed" : false,
      "module" : "posts",
      "action" : "update",
      "level" : 3,
      "group" : "headOffice"
    }

The rule can be read as, "Allow head office users of grade 3, 2, 1 or
0 to update posts".

The levels numbering is somewhat simplistic.  It supports multiple
one-dimensional arrays of levels, one per organizational unit, rather
than 2D arrays or unstructured tags.

For now the set of levels mnemonics is hard-coded in the file,
'server/methods/_users.js', as follows :

    const AllRoles = [ 
      'Owner',
      'Administrator',
      'Staff',
      'Member',
      'Customer',
      'Registered' 
    ];

A typical user record would contain :

    {
        :     :     :
        :     :     :
      "profile" : {
        "firstName" : "Oscar",
        "lastName" : "Dávila"
      },
      "roles" : {
        "headOffice" : [
          "Member",
          "Customer",
          "Registered"
        ]
      }
    }

The record can be read as, "While Oscar Dávila represents head office,
he has permissions of grades 3, 4 & 5.

These three React/Mantra units handle client-side authorizations : 
- client/access_control/acComponent.jsx
- client/access_control/acComposer.js
- client/access_control/acContainer.js

Server-side Meteor methods directly interrogate the Astronomy class,
'/lib/access_control.js'.  That class exposes a method
'canTrust(context, _idUser, _accessPoint)'. In which an access point is
a 'module, action' pair, such as 'posts, update'.

'canTrust' returns a synchronous value to server-side methods.  It also
writes a 'hook' into LocalState, to be interrogated by client-side
components needing to allow or prohibit a user. A 'hook' is a unique key
of the form, "module:action:group:userId". 'canTrust' wraps the query in
a Tracker.autorun() function to ensure that database changes
automagically percolate up to all interested client-side artifacts.

The client-side container 'client/access_control/acContainer.js' can be
used in the render method of a React.Component like this :

      import Authorized from '/client/access_control/acContainer.js';
          :   :
          :   :
          <Authorized accesspoints={accPnts} warn='true'>
            <Container />
          </Authorized>

The container will either :
 - render the child component or 
 - render a provided UnauthenticatedMessage or
 - render the DefaultUnauthenticatedMessage

The DefaultUnauthenticatedMessage looks like this :

          <div>
            <h3>
              We apologize for the inconvenience.
            </h3>
            <x-cuke id="warning">
              You haven't been authorized to access this page.
            </x-cuke>
          </div>

(The tag '<x-cuke />' exists to simplify writing Chimp Cucumber tests.)

The access control composer 'client/access_control/acComposer.js' can be
used by any other container composer to inject an array of permissions
into the  props of the embedded component for item by item control
internally.

Eg, the container, 'client/modules/_colors/containers/single.jsx' passes
two access points into its child container, the child container's
composer uses 'acComposer' to establish the reactive state hooks. The
hook's states are passed into the embedded component as an array of
specific 'permissions'.

So in 'client/modules/_colors/components/_single.jsx' the 'edit' and
'delete' buttons will be enabled or disabled in immediate response to
changes in the database.

A dropdown menu in 'client/modules/layout/components/NavLeftContent.jsx'
offers a further example.  The sub-menu item 'colors/add' has the same
reactive responsivity.

So far, authorizations are implemented for the '_colors' module, only.
